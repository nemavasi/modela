MODULE Init;

IMPORT Log, D := Draw, JS, Strings, Math;

CONST 
 
  dBtn = 10.0; (* расстояние между кнопками *) 
  width = 401.0; height = 451.0; (* размеры холста *)
  greenColor = 0FFCCFFAAH;
  
  productACode = 0;
  productBCode = 1;
  productCCode = 2;  

  productsCount = 3; (* размер номенклатуры изделий *)

  maxStoreAmountForView = 500.0; (* максимально показываемый объем запасов *)

  (* коды вьюх *)
  viewTurnCode = 3;
  viewTotalCode = 4;
  viewProductACode = 0;
  viewProductBCode = 1;
  viewProductCCode = 2;
  viewStoreGraphicsCode = 5;

  maxTotalPlanTime = 480.0; (* минут за смену *)
  maxTurn = 100; (* максимальное количество смен за игру *)

  storeGraphHeight = 300.0; (* высота графика запасов *)
  
  (* все единицы измерения времени в минутах *)
TYPE 
  AnyRec = RECORD END;
  Node = POINTER TO RECORD 
    rec    : POINTER TO AnyRec; 
    next   : Node
  END;
   
  Product = POINTER TO RECORD (AnyRec)     
    name             : ARRAY 100 OF CHAR;
    workTime         : REAL; (* время обработки единицы изделия *)
    changeoverTime   : REAL; (* время перенастройки на это изделие *)
    plan             : REAL; (* количество изделий, которое надо произвести за смену *)
    stock            : REAL; (* количество изделий на складе на начало смены *)
    order            : REAL; (* количество изделий на сегодня, которые заберут сегодня со склада - должно быть на складе на начало смены*)
    meanOrder        : REAL; (* средний заказ, шт *)
    amplitudeOrder   : REAL; (* размер колебания заказа *)
    listeners        : Node; (* список вьюшек для уведомления *) 
    color            : INTEGER
  END;
  View = POINTER TO RECORD (AnyRec)  
    x, y             : REAL; (* левый верхний угол *)
    height, width    : REAL;  (* высота и ширина вьюшки *)       
    label            : ARRAY 100 OF CHAR;
    bgColor          : INTEGER;
    txtColor         : INTEGER;
    overBgColor      : INTEGER;   (* цвет когда под указателем мыши *)
    ClickProc        : PROCEDURE;
    UpdateProc       : PROCEDURE (view : View);  (* процедура апдейта вьюхи *)
    model            : Product
  END;
  StoreBalanceHistRec = POINTER TO RECORD (AnyRec)
    nTurn : INTEGER; 
    amounts : ARRAY productsCount OF REAL   
  END;

VAR 
  products : ARRAY productsCount OF Product;
  views : ARRAY (productsCount + 3) OF View;
  totalPlanTime : REAL; (* всего необходимо минут на плановое количество *)
  nTurn  : INTEGER; (* номер хода *)
  viewsForUpdate : Node;  (* список вьюх. которые надо обновить перед отрисовкой *)
  storeBalanceHistory : Node; (* история изменения остатков склада - последние записи сверху*)
  

PROCEDURE SaveStoreHistory;
  VAR rec : StoreBalanceHistRec; node : Node; i: INTEGER;
BEGIN
  NEW(rec);
  rec.nTurn  := nTurn;
  FOR i := 0 TO LEN(products) - 1 DO
    rec.amounts[i] := products[i].stock;
  END;
  NEW(node);
  node.rec := rec; 
  IF storeBalanceHistory = NIL THEN
    storeBalanceHistory := node
  ELSE 
    node.next := storeBalanceHistory;
    storeBalanceHistory := node;
  END;
END SaveStoreHistory;

PROCEDURE CalcTotalTime;
VAR i : INTEGER;
BEGIN
  totalPlanTime := 0.0;
  FOR i := 0 TO LEN(products)-1 DO 
    totalPlanTime := totalPlanTime + products[i].plan * products[i].workTime;
    IF products[i].plan > 0.0 THEN
      totalPlanTime := totalPlanTime + products[i].changeoverTime;
    END;
  END; 
END CalcTotalTime; 

PROCEDURE GetOrders;
VAR i : INTEGER;
BEGIN 
  FOR i := 0 TO LEN(products)-1 DO    
    products[i].order := products[i].meanOrder + products[i].amplitudeOrder * Math.Rnd();     
    products[i].order := products[i].order - products[i].amplitudeOrder * Math.Rnd();  
    IF products[i].order < 0.0 THEN 
      products[i].order := 0.0;
    END;    
  END; 
END GetOrders;

PROCEDURE SendOrdersToConsumers;
VAR i : INTEGER;
BEGIN 
  FOR i := 0 TO LEN(products)-1 DO    
    products[i].stock := products[i].stock - products[i].order;    
  END; 
END SendOrdersToConsumers;

PROCEDURE AddProductsToStock;
VAR i : INTEGER;
BEGIN 
  FOR i := 0 TO LEN(products)-1 DO    
    products[i].stock := products[i].stock + products[i].plan;    
  END; 
END AddProductsToStock;

PROCEDURE InitData*;
BEGIN
  nTurn := 0;
  NEW(products[0]);
  products[0].name := "A"; 
  products[0].workTime := 3.0; 
  products[0].changeoverTime := 60.0; 
  products[0].plan := 0.0; 
  products[0].stock := 160.0;
  products[0].meanOrder := 30.0;
  products[0].amplitudeOrder := 10.0;
  products[0].color := 0FFFF0000H;
  
  NEW(products[1]);
  products[1].name := "B"; 
  products[1].workTime := 3.0; 
  products[1].changeoverTime := 60.0; 
  products[1].plan := 0.0; 
  products[1].stock := 150.0;
  products[1].meanOrder := 30.0;
  products[1].amplitudeOrder := 10.0;
  products[1].color := 0FF00FF00H;
 
  NEW(products[2]);
  products[2].name := "C";
  products[2].workTime := 2.0; 
  products[2].changeoverTime := 120.0; 
  products[2].plan := 0.0; 
  products[2].stock := 170.0;   
  products[2].meanOrder := 30.0;
  products[2].amplitudeOrder := 10.0;
  products[2].color := 0FF0000FFH;
  
  CalcTotalTime;
 
END InitData;

PROCEDURE Check(num : ARRAY OF CHAR) : BOOLEAN;
VAR
  i, k, l : INTEGER;
  result : BOOLEAN;
BEGIN  
  result := TRUE;  
  l := LEN(num); 
  IF l < 4 THEN 
    (* Проверка допустимых символов *)
    FOR i := 0 TO l-1 DO
      IF (ORD(num[i]) < 48) OR (ORD(num[i]) > 57) THEN   
        result := FALSE;         
      END
    END;     
  ELSE 
     result := FALSE; 
  END; 
  RETURN result
END Check;

PROCEDURE Ask(VAR arg: ARRAY OF CHAR);
 VAR 
  value: ARRAY 1000 OF CHAR;
  i, l : INTEGER;
  repeatAgain : BOOLEAN;
BEGIN 
  REPEAT     
    repeatAgain := FALSE;  
    JS.do( "result = prompt('Планируемое кол-во за смену: ', '?'); value = result;" );      
    repeatAgain := ~Check(value);
    IF ~repeatAgain THEN           
      FOR i := 0 TO LEN(value)-1 DO         
        arg[i] := value[i]        
      END  
    END 
  UNTIL ~repeatAgain;
END Ask;

PROCEDURE IsWrongTotalPlanTime() : BOOLEAN;
VAR result : BOOLEAN;
BEGIN
  IF totalPlanTime > maxTotalPlanTime THEN
    result := TRUE
  ELSE
    result := FALSE
  END;
  RETURN result
END IsWrongTotalPlanTime; 

PROCEDURE AddViewForUpdate(view : View);
VAR node : Node;
BEGIN    
  NEW(node);
  node.rec := view;
  IF viewsForUpdate = NIL THEN
    viewsForUpdate := node;
  ELSE    
    node.next := viewsForUpdate;
    viewsForUpdate := node;
  END
END AddViewForUpdate;

PROCEDURE IsGameOver() : BOOLEAN;
VAR result : BOOLEAN; i : INTEGER;
BEGIN
  result := FALSE;
  FOR i := 0 TO LEN(products) - 1 DO
    IF products[i].stock < 0.0 THEN
      result := TRUE  
    END;
  END;
  RETURN result
END IsGameOver;
 
PROCEDURE Turn;
VAR i : INTEGER; node : Node;
BEGIN    
  IF nTurn >= 0 THEN
    IF IsWrongTotalPlanTime() THEN  
      JS.do("alert('Плановое время не может превысить 480 минут!')"); 
    ELSE (* стандартный ход *)
      GetOrders; 
      SendOrdersToConsumers;   
      AddProductsToStock;
      (* добавляем в список обновлений *)
      FOR i := 0 TO LEN(products) - 1 DO          
          node := products[i].listeners;
          WHILE node # NIL DO            
            AddViewForUpdate(node.rec(View));  
            node := node.next;
          END;        
      END;  
      AddViewForUpdate(views[viewStoreGraphicsCode]);   
      SaveStoreHistory;
      nTurn := nTurn + 1;
    END;   
    IF IsGameOver() THEN 
      JS.do("alert('Вы проиграли!')"); 
      nTurn := -1; (* после этого кнопка хода перестает работать *)
    ELSIF nTurn >= maxTurn THEN 
      JS.do("alert('Вы выиграли!')"); 
      nTurn := -1; (* после этого кнопка хода перестает работать *)
    END;
  END;
END Turn;

PROCEDURE IsOverView(view : View) : BOOLEAN;
BEGIN
  RETURN D.focus & (D.mouseX > view.x) & (D.mouseX < view.x + view.width) & (D.mouseY > view.y) & (D.mouseY < view.y + view.height)
END IsOverView;

PROCEDURE UpdateTotalTimeLabel*(VAR label : ARRAY OF CHAR);
VAR str, strInt : ARRAY 100 OF CHAR; i : INTEGER;
BEGIN
  str := "Итого (мин.):       ";
  strInt := "";
  Strings.IntToString(FLOOR(totalPlanTime), strInt); 
  Strings.Join(str, strInt);
  FOR i := 0 TO LEN(str)-1 DO  
    label[i] := str[i];
  END; 
END UpdateTotalTimeLabel;

PROCEDURE UpdateProductLabel*(VAR label : ARRAY OF CHAR; p : Product);
VAR str, strInt : ARRAY 100 OF CHAR; i : INTEGER;
BEGIN  
  str := "по "; 
  Strings.Join(str, p.name);  
  Strings.Join(str, ": ");
  strInt := "";
  Strings.IntToString(FLOOR(p.plan), strInt); 
  Strings.Join(str, " ");
  Strings.Join(str, strInt);
  Strings.Join(str, " шт., (склад: ");
  Strings.IntToString(FLOOR(p.stock), strInt);
  Strings.Join(str, strInt);
  Strings.Join(str, " шт.)");   
  FOR i := 0 TO LEN(str)-1 DO 
    label[i] := str[i];
  END; 
  
END UpdateProductLabel;

PROCEDURE UpdateProductView (view : View);
VAR str : ARRAY 100 OF CHAR;
BEGIN    
  UpdateProductLabel(str, view.model);  
  view.label := str;  
END UpdateProductView; 

PROCEDURE UpdateTotalView (view : View);
VAR str : ARRAY 100 OF CHAR;
BEGIN    
  CalcTotalTime;
  UpdateTotalTimeLabel(views[viewTotalCode].label);  
END UpdateTotalView; 

PROCEDURE InputProductCount;
VAR i, k, cnt, code : INTEGER; str, strInt : ARRAY 100 OF CHAR; v : ARRAY 3 OF CHAR; node : Node;
BEGIN     
  FOR i := 0 TO LEN(views) - 1 DO
    IF (views[i].ClickProc # NIL) & IsOverView(views[i]) THEN
      IF i < LEN(products) THEN 
        Ask(v); 
        cnt := 0;
        k := 0;
        WHILE (k <= LEN(v)-1) & (ORD(v[k]) # 0) DO
          cnt := cnt * 10 + ORD(v[k]) - ORD("0");         
          k := k + 1;          
        END;
        products[i].plan := FLT(cnt);        
        (* добавляем в список обновлений *)
        node := products[i].listeners;
        WHILE node # NIL DO            
          AddViewForUpdate(node.rec(View));  
          node := node.next;
        END;
      END; 
    END;
  END;  
END InputProductCount;

PROCEDURE UpdateStoreGraphicsView (view : View);
  VAR node : Node; i : INTEGER; x, y : REAL;
BEGIN
  (* сначала определяем масштабирование по вертикали *)
  (*
  maxStoreAmount := 0.0;
  node := storeBalanceHistory;
  WHILE node # NIL DO    
    FOR i := 0 TO LEN(products)-1 DO      
      IF node.rec(StoreBalanceHistRec).amounts[i] > maxStoreAmount THEN
        maxStoreAmount := node.rec(StoreBalanceHistRec).amounts[i];
      END;    
    END;
    node := node.next;
  END;
  *)   
  (* отрисовываем точки *)
  node := storeBalanceHistory;
  D.NoStroke;
  WHILE node # NIL DO
    FOR i := 0 TO LEN(products)-1 DO  
      D.Fill(products[i].color);      
      x := 4.0*FLT(node.rec(StoreBalanceHistRec).nTurn) + 5.0;
      y := storeGraphHeight - node.rec(StoreBalanceHistRec).amounts[i] * (storeGraphHeight/maxStoreAmountForView);
      (*Log.Real(x); Log.Ln;
      Log.Real(y); Log.Ln;*)
      D.Rect(x, y, 5.0,5.0);        
    END; 
    node := node.next;
  END; 
  D.Stroke(0H);
  D.Fill(0H);   
END UpdateStoreGraphicsView; 

PROCEDURE InitViews*;
VAR
  node : Node;
  i : INTEGER;
BEGIN
  (* Всего минут *)
  NEW(views[viewTotalCode]);
  views[viewTotalCode].x := 1.0; 
  views[viewTotalCode].height := 24.0; 
  views[viewTotalCode].y := height - views[viewTotalCode].height - 1.0; 
  views[viewTotalCode].width := 240.0;
  UpdateTotalTimeLabel(views[viewTotalCode].label);  
  views[viewTotalCode].bgColor := 255H; 
  views[viewTotalCode].txtColor := 0H; 
  views[viewTotalCode].overBgColor := 255H; 
  views[viewTotalCode].UpdateProc := UpdateTotalView;
 
  (* добавляем как слушатель *)
  FOR i := 0 TO LEN(products) - 1 DO
    NEW(node);
    node.rec := views[viewTotalCode];  
    products[i].listeners := node;     
  END;  
 
  (* кнопка старт *)
  NEW(views[viewTurnCode]);
  views[viewTurnCode].x := 1.0 + views[viewTotalCode].width + dBtn; 
  views[viewTurnCode].height := 24.0; 
  views[viewTurnCode].y := height - views[viewTurnCode].height - 1.0; 
  views[viewTurnCode].width := 100.0;
  views[viewTurnCode].label := "Работать";
  views[viewTurnCode].bgColor := 255H; 
  views[viewTurnCode].txtColor := 0H; 
  views[viewTurnCode].overBgColor := greenColor;
  views[viewTurnCode].ClickProc := Turn;
  (* Продукт A *) 
  NEW(views[viewProductACode]);
  views[viewProductACode].x := 1.0; 
  views[viewProductACode].height := 24.0; 
  views[viewProductACode].y := height - 2.0*views[viewProductACode].height - 1.0 - dBtn; 
  views[viewProductACode].width := views[viewTotalCode].width; 
  UpdateProductLabel(views[viewProductACode].label, products[viewProductACode]);  
  views[viewProductACode].bgColor := 255H; 
  views[viewProductACode].txtColor := 0H; 
  views[viewProductACode].overBgColor := greenColor;
  views[viewProductACode].ClickProc := InputProductCount; 
  views[viewProductACode].UpdateProc := UpdateProductView;
  views[viewProductACode].model := products[viewProductACode];  
  (* добавляем как слушатель *)
  NEW(node);
  node.rec := views[viewProductACode];
  products[0].listeners.next := node; 
  
  
  (* Продукт B *) 
  NEW(views[viewProductBCode]);
  views[viewProductBCode].x := 1.0; 
  views[viewProductBCode].height := 24.0; 
  views[viewProductBCode].y := height - 3.0*views[viewProductBCode].height - 1.0 - 2.0*dBtn; 
  views[viewProductBCode].width := views[viewTotalCode].width; 
  UpdateProductLabel(views[viewProductBCode].label, products[viewProductBCode]);  
  views[viewProductBCode].bgColor := 255H; 
  views[viewProductBCode].txtColor := 0H; 
  views[viewProductBCode].overBgColor := greenColor;
  views[viewProductBCode].ClickProc := InputProductCount; 
  views[viewProductBCode].UpdateProc := UpdateProductView;
  views[viewProductBCode].model := products[viewProductBCode]; 
  (* добавляем как слушатель *)
  NEW(node);
  node.rec := views[viewProductBCode];
  products[1].listeners.next := node; 
 
  (* Продукт C *) 
  NEW(views[viewProductCCode]);
  views[viewProductCCode].x := 1.0; 
  views[viewProductCCode].height := 24.0; 
  views[viewProductCCode].y := height - 4.0*views[viewProductBCode].height - 1.0 - 3.0*dBtn; 
  views[viewProductCCode].width := views[viewTotalCode].width; 
  UpdateProductLabel(views[viewProductCCode].label, products[viewProductCCode]);  
  views[viewProductCCode].bgColor := 255H; 
  views[viewProductCCode].txtColor := 0H; 
  views[viewProductCCode].overBgColor := greenColor;
  views[viewProductCCode].ClickProc := InputProductCount; 
  views[viewProductCCode].UpdateProc := UpdateProductView;
   views[viewProductCCode].model := products[viewProductCCode]; 
  (* добавляем как слушатель *)
  NEW(node);
  node.rec := views[viewProductCCode];
  products[2].listeners.next := node;    
 
  (* отображение графиков запасов *)
  NEW(views[viewStoreGraphicsCode]);
  views[viewStoreGraphicsCode].x := 1.0; 
  views[viewStoreGraphicsCode].height := storeGraphHeight; 
  views[viewStoreGraphicsCode].y := 1.0 ; 
  views[viewStoreGraphicsCode].width := width - 10.0;     
  views[viewStoreGraphicsCode].bgColor := 255H; 
  views[viewStoreGraphicsCode].txtColor := 0H; 
  views[viewStoreGraphicsCode].overBgColor := 255H;
  views[viewStoreGraphicsCode].ClickProc := NIL; 
  views[viewStoreGraphicsCode].UpdateProc := NIL;
  views[viewStoreGraphicsCode].model := NIL;  
END InitViews;

PROCEDURE Setup*;
BEGIN
  InitData;
  InitViews;  
  D.SetSize(FLOOR(width), FLOOR(height));
  D.SetFrameRate(20);
END Setup;

PROCEDURE DrawView (view : View); (* рисуем вьюху*)
BEGIN
  D.Fill(view.bgColor);
  IF IsOverView(view) THEN D.Fill(view.overBgColor) ELSE D.NoFill END;
  D.StrokeWidth(1);
  D.RectRounded(view.x, view.y, view.width, view.height, 3.0);
  D.Fill(view.txtColor);   
END DrawView; 

PROCEDURE DrawTextView (view : View); (* рисуем текстовую вьюху*)
BEGIN
  DrawView(view);
  IF LEN(view.label) > 0 THEN 
    D.Stringi(view.label, FLOOR(view.x) + 17, FLOOR(view.y + view.height) - 6, 16);  
  END;
END DrawTextView; 

PROCEDURE Plot;
  VAR i: INTEGER; node : Node; v: View;
BEGIN  
  (* сначала апдейтим все вьюхи которые нужно обновить так как изменились данные в моделях *)
  
  WHILE viewsForUpdate # NIL DO  
   node := viewsForUpdate;  
   v := node.rec(View);
   IF v.UpdateProc # NIL THEN 
     v.UpdateProc(v);
   END;   
    viewsForUpdate := viewsForUpdate.next;
  END;    
  D.SetBackground(255H); 
  FOR i := 0 TO LEN(views) - 2 DO
    DrawTextView(views[i]);
  END;
  UpdateStoreGraphicsView(NIL);
END Plot;

PROCEDURE Released;
VAR i : INTEGER;
BEGIN
  FOR i := 0 TO LEN(views) - 1 DO
    IF (views[i].ClickProc # NIL) & IsOverView(views[i]) THEN
      views[i].ClickProc();
    END;
  END;  
END Released;

BEGIN
  (* инициализация графики *)
  D.CreateCanvas("canvas");  
  D.SetSetupProc(Setup);
  D.SetDrawProc(Plot);
  D.SetReleasedProc(Released);  
  D.Start; 
END Init.
(* todo 
  - графики изменения запасов
  - раскраска изделий или легенда графика
  - подсветка Итого  
  - вложенные вьюхи
  - каждая вьюха сама знает как себя рисовать  
  - убрать коды моделей - связь только по полям вьюх
  - отделить бизнес-логику в отдельный модуль? 

    НА ПОТОМ
  - евенты + сами события
  - уровень сложности
  - репутация игрока
  - тайм-менеджмент + мероприятия по улучшению процессов
   
*)
(*
    Copyright (C) 2019  Dmitry Shalygin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*)
